Mail Receive
============

Description
-----------

Uses a rtos mailbox with the instance number 1...9. This has to be created by RTOS Mail Send.

A new mail is announced at the new output port.
Reading one mail more then available will suspend the reading thread until the next mail is received or a timeout after the specified time is generated.

A timeout value of 4294967295 (osWaitForever) means waiting forever.
With a timeout smaller than 4294967295 the specified number of milliseconds is waited.

Each mail can contain the specified number of elements with the specified data type.

.. image:: ../images/block_RTOSMailReceive.png
   :scale: 50 %

Data Type Support
-----------------

The output port *d* writes values with configured data type. Single or vector values are written, depending on the configured Number of output elements parameter.

The output port *new* writes an *uint8* value of 1 when a new mail is received. Otherwise a 0 is written.

.. warning::
  You must use the same number of elements per mail and data type as configured in the connected Mail Send block.

Parameters and Dialog Box
-------------------------

.. image:: ../images/mask_RTOSMailReceive.png


Mail Instance Number
....................
specifies an internal mail box number. It is used to generate unique instance names when more mail boxes are included in the same model and to tie Mail Send and mail Receive blocks together.

Timeout
.......
specifies the timeout in milliseconds. A value of 4294967295 (osWaitForever) means waiting forever.

Number of input elements
........................
pecifies the number of data elements in each mail.

Data type
.........
specifies the data type of each element in a mail. All data elements have the same type. The following types are possible:

- double
- single
- int8
- uint8
- int16
- uint16
- int32
- uint32

Example
-------

The example realises again a LED blinking. This time the generator creates periodically mails. The function call subblock runs in a Thread in an endless loop without wait. 
But reading from an empty Mail queue blocks the thread until a message is received. When it received one, the contents, a single *uint8* value, is written to LED1. The following mail.get() in Mail Receive block blocks again until the next mail is generated.

.. image:: ../images/example_RTOS_Mail_Blinky.png
   :scale: 50 %

Code Generation
---------------
Instance name of mbed class Mail is created by concatenating mail_box and the Mail Instance Number: mail_box<Mail Instance Number>


Step Function
.............

creates this block in void **<Model Name>**\ _step(void) function

.. code-block:: c++

  osEvent evt<Mail Instance Number> = mail_box<Mail Instance Number>.get(<Timeout>);
  if(evt<Mail Instance Number>.status == osEventMail)
  {
    mail<Mail Instance Number>_T *mail<Mail Instance Number>_ptr = (mail<Mail Instance Number>_T*)evt<Mail Instance Number>.value.p;
    memcpy(<pointer to output port d data vector>, mail<Mail Instance Number>_ptr, mail<Mail Instance Number>_len);
    mail_box<Mail Instance Number>.free(mail<Mail Instance Number>_ptr);
    <output port new> = 1;
  }
  else
  {
    <output port new> = 0;
  }

Here is a concrete example with Mail Instance Number = 1 and Timeout = 4294967295 (osWaitForever)

.. code-block:: c++

  osEvent evt1 = mail_box1.get(osWaitForever);
  if (evt1.status == osEventMail) {
    mail1_T *mail1_ptr = (mail1_T*)evt1.value.p;
    memcpy(&rtb_RTOSMailReceive_o1, mail1_ptr, mail1_len);
    mail_box1.free(mail1_ptr);
    rtb_RTOSMailReceive_o2 = 1;
  } else {
    rtb_RTOSMailReceive_o2 = 0;
  }
