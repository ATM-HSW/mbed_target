%% Copyright 2010 The MathWorks, Inc.
%% Copyright 2014 Dr.O.Hagendorf, HS Wismar
%% MAX11300 Modifications by Axel Utech 2014, HS Wismar
%% Copyright 2015 M. Marquardt, HS Wismar

%implements sfunar_max11300Config "C"

%include "block_common_includes.tlc"

%% Function: BlockTypeSetup ===============================================
%function BlockTypeSetup(block, system) void
  
  %% Ensure required header files are included
  %<MbedCommonBlockTypeSetup(block, system)>

%endfunction


%% Function: Start ========================================================
%function Start(block, system) Output

  %assign p2_val = LibBlockParameterValue(p1,0)
  %assign p3_val = LibBlockParameterValue(p2,0)
  %assign cs_name = "P" + FEVAL("char",p2_val+64) + "_" + FEVAL("int2str",p3_val-1)

  %assign adcconv = LibBlockParameterValue(p3,0)
  %assign dacref = LibBlockParameterValue(p4,0)

  %assign spiport_val = CAST("Number", LibBlockParameterValue(SpiPort,0))

  %if !SLibCodeGenForSim()
    %openfile declbuf
    %%

#if defined(MAX11300_DEVICE)
    #error "Multiple MAX11300 Config blocks not supported"
#endif
#define MAX11300_DEVICE

DigitalOut cs_max11300(%<cs_name>);

#define MAX11300_DEVICE_CONTROL_ADDR (0x10)

#define MAX11300_DEVICE_CONTROL_ADCCTL_CONTINOUS (3)
#define MAX11300_DEVICE_CONTROL_DACCTL_SEQUENTIUAL (0<<2)
#define MAX11300_DEVICE_CONTROL_TEMP_ENABLE (7<<8)

#define MAX11300_DEVICE_CONTROL_ADCCONV_200KSPS (0)
#define MAX11300_DEVICE_CONTROL_ADCCONV_250KSPS (1)
#define MAX11300_DEVICE_CONTROL_ADCCONV_333KSPS (2)
#define MAX11300_DEVICE_CONTROL_ADCCONV_400KSPS (3)
#define MAX11300_DEVICE_CONTROL_ADCCONV_SHIFT (4)

#define MAX11300_DEVICE_CONTROL_DACREF_EXTERNAL (0)
#define MAX11300_DEVICE_CONTROL_DACREF_INTERNAL (1)
#define MAX11300_DEVICE_CONTROL_DACREF_SHIFT (6)

void max11300_writeReg(uint8_t addr, uint16_t data){
     cs_max11300 = 0;
     
     uint8_t chip_addr = (addr << 1) | 0;
     spi%<spiport_val>.write(chip_addr);
     
     spi%<spiport_val>.write(data >> 8);
     spi%<spiport_val>.write(data & 0xff);
     
     cs_max11300 = 1;
}
uint16_t max11300_readReg(uint8_t addr) {
     uint16_t data = 0;
     uint8_t in;
     cs_max11300 = 0;
     uint8_t chip_addr = (addr << 1) | 1;
     spi%<spiport_val>.write(chip_addr);
     
     in = spi%<spiport_val>.write(0);
     data = (uint16_t)in << 8;
     
     in = spi%<spiport_val>.write(0);
     data |= in;
     
     cs_max11300 = 1;
     return data;
}

bool max11300_writeCheckReg(uint8_t addr, uint16_t data){
	max11300_writeReg(addr, data);
	uint16_t ret = max11300_readReg(addr);
	return ret == data;
}
 
bool max11300_deviceConfig(uint8_t adcconv, bool dacRefInternal){
	uint16_t data = MAX11300_DEVICE_CONTROL_ADCCTL_CONTINOUS | MAX11300_DEVICE_CONTROL_DACCTL_SEQUENTIUAL;
    data |= MAX11300_DEVICE_CONTROL_TEMP_ENABLE;
    data |= adcconv << MAX11300_DEVICE_CONTROL_ADCCONV_SHIFT;
	data |= dacRefInternal << MAX11300_DEVICE_CONTROL_DACREF_SHIFT;
	return max11300_writeCheckReg(MAX11300_DEVICE_CONTROL_ADDR, data);
}

bool max11300_pinSetup(uint8_t pinNumber, uint8_t mode, uint8_t associatedPort, 
		uint8_t powerOfSamples, uint8_t range, bool adcRefExternal, bool invertInput){
	uint16_t reg = 0;
	reg |= (associatedPort & 0x1f) << 0;
	reg |= (powerOfSamples & 7) << 5;
	reg |= (range & 7) << 8;
	if(mode == 4 || mode == 11)
		reg |= invertInput << 11;
	else
		reg |= adcRefExternal << 11;
	reg |= (mode & 0xf) << 12;
	return max11300_writeCheckReg(0x20 + pinNumber, reg);
}
uint16_t max11300_getAdcValue(uint8_t pin, uint8_t pinMode){
	uint16_t data = max11300_readReg(0x40 + pin);
	if(pinMode == 8 && data & 1<<11)
		data |= 0xF000; // set MSBs
	return data;
}

bool max11300_setDacValue(uint8_t pin, uint16_t value){
	return max11300_writeCheckReg(0x60 + pin, value);
}
uint16_t max11300_getTemperature(uint8_t channel){
	return max11300_readReg(0x08 + channel);
}
double max11300_convertTemperature(uint16_t temp){
	return temp * .125;
}
bool max11300_getPinValue(uint8_t pin){
	if(pin <= 15){
		uint16_t reg = max11300_readReg(0x0B);
		return !!(reg & 1<<pin);
	}else{
		uint16_t reg = max11300_readReg(0x0C);
		return !!(reg & 1<<(pin-16));
	}
}
bool max11300_setPinValue(uint8_t pin, bool value){
	uint16_t regAddr, pinBit;
	if(pin <= 15){
		regAddr = 0x0D;
		pinBit = 1<<pin;
	}else{
		regAddr = 0x0E;
		pinBit = 1<<(pin-16);
	}
	uint16_t reg = max11300_readReg(regAddr);
	if(value)
		reg |= pinBit;
	else
		reg &= ~pinBit;		

	return max11300_writeCheckReg(regAddr, reg);
}



    %%
    %closefile declbuf
    %assign srcFile = LibGetModelDotCFile()
    %<LibSetSourceFileSection(srcFile, "Functions", declbuf)>
    cs_max11300=1;
max11300_deviceConfig(%<adcconv>, %<dacref>);
  %endif
%endfunction
