%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Abstract:
%%   Custom file processing to generate a "main" file.
%%
%% Copyright 1994-2014 The MathWorks, Inc.
%%           2014 Dr. Olaf Hagendorf, HS Wismar
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%selectfile NULL_FILE

%function FcnSingleTaskingMain() void

  %if GenerateSampleERTMain
    %assign CompiledModel.GenerateSampleERTMain = TLC_FALSE
  %endif

  %if LibIsModelReferenceTarget()
    %return
  %endif

  %assign cFile = LibCreateSourceFile("Source", "Custom", "ert_main")

  %openfile tmpBuf
  #include "%<LibGetMdlPubHdrBaseName()>.h"
  #include "mbed.h"
  #include "rtos.h"
  %closefile tmpBuf

  %<LibSetSourceFileSection(cFile, "Includes", tmpBuf)>

  %openfile tmpBuf

  /* Overrun counter */
  static uint8_t uOverrunCounter;

  %% Get fundamental step time
  %assign SAMPLETIME = CompiledModel.FundamentalStepSize
  %if SAMPLETIME < 0.00005
      %% Even 50 microseconds is too quick for Arduino
      %<LibReportError("The minimum supported sample time is 50 microseconds. Change the Sample time parameter in blocks that use incorrect sample times.")>
  %endif
  %assign SampleRate_us  = CAST("Number", %<SAMPLETIME> * 1000000)
  %assign SampleRate_ms  = CAST("Number", %<SAMPLETIME> * 1000)
  
  #define STEP_SIZE_US %<SampleRate_us>UL /* Sample Time in microseconds */
  #define STEP_SIZE_MS %<SampleRate_ms>UL /* and in milliseconds */

  %closefile tmpBuf

  %<LibSetSourceFileSection(cFile, "Declarations", tmpBuf)>

  %if UseMbedRTOS
  
  %openfile tmpBuf

	%if EXISTS(::ThreadPrototypes)
		%<::ThreadPrototypes>
	%endif

  void step(void const *param) {
    %<LibCallModelStep(0)>
  }
  
  /* with RTOS */
  int main(void) {

    /* initialize model */
    %<LibCallModelInitialize()>\
	
    RtosTimer step_1_timer(step, osTimerPeriodic, (void *)0);
	
	%if EXISTS(::ThreadInstances)
		%<::ThreadInstances>
	%endif

    %if ExtMode
        %<SLibGenERTExtModeInit()>
    %endif

    /* start Timer for main step function */
    step_1_timer.start(STEP_SIZE_MS);

    /* main task waits forever */
    Thread::wait(osWaitForever);

    /* deinitialize model */
    %<LibCallModelTerminate()>\
	
	return 0;
  }
  %closefile tmpBuf

  %else

  %openfile tmpBuf
  
  uint8_t GetOverrunCounter(void)
  {
  	return uOverrunCounter;
  }

  // without RTOS
  int main(void)
  {
    unsigned long oldTime;
    unsigned long actualTime;
    
    /* initialize model */
    %<LibCallModelInitialize()>\

    %if ExtMode
        %<SLibGenERTExtModeInit()>
    %endif

    oldTime = us_ticker_read();
    while (true) {
        /* call main step function */
	    %<LibCallModelStep(0)>\

        actualTime = us_ticker_read();
        /* Overrun check */
        if ((actualTime - oldTime) >= STEP_SIZE_US) {
            /* We missed our time slot for actual step, report it! */
            if(uOverrunCounter < 255U){
                uOverrunCounter++;
            }
            oldTime = actualTime;               /* Update time stamp of last step */
            continue;                           /* We are late, continue with next step */
        }\

        /* Waiting with pooling method */
        while((actualTime - oldTime) < STEP_SIZE_US){
            actualTime = us_ticker_read();                  /* Get actual time */
        }
        oldTime = actualTime;                       /* Update time stamp of last step */
    }

    /* deinitialize model */
    %<LibCallModelTerminate()>\
	
	return 0;
  }
	
  %closefile tmpBuf
  
  %endif
  
  %<LibSetSourceFileSection(cFile, "Functions", tmpBuf)>

%endfunction
